{"version":3,"file":"qr-scanner-x.min.js","sources":["src/qr-scanner.js"],"sourcesContent":["/**\n * 获取摄像头\n */\nfunction getCams() {\n  if (!navigator.mediaDevices) return Promise.resolve([])\n  return navigator.mediaDevices\n    .enumerateDevices()\n    .then((devices) => {\n      return devices.filter((device) => {\n        return device.kind === 'videoinput'\n      })\n    })\n    .then((cams) => {\n      return cams.map((cam, index) => {\n        const { deviceId, groupId, kind, label } = cam\n        let camInfo = { deviceId, groupId, kind, label }\n        camInfo.label = label || `Camera ${index + 1}`\n        return camInfo\n      })\n    })\n    .catch((err) => {\n      console.log(err)\n      return []\n    })\n}\n\n/**\n * 请求相机权限\n */\nfunction _requestPermission() {\n  const defaultResult = { permission: false, cams: [] }\n  if (!navigator.mediaDevices) return Promise.resolve(defaultResult)\n  return navigator.mediaDevices\n    .getUserMedia({ video: true })\n    .then(async (stream) => {\n      let permission = true\n      let cams = await getCams()\n      stream.getTracks().forEach((track) => {\n        track.stop()\n      })\n      return { permission, cams }\n    })\n    .catch((error) => {\n      console.log(error)\n      return defaultResult\n    })\n}\n\nexport default class QrScanner {\n  /* async */\n  static hasCamera() {\n    if (!navigator.mediaDevices) return Promise.resolve(false)\n    // note that enumerateDevices can always be called and does not prompt the user for permission. However, device\n    // labels are only readable if served via https and an active media stream exists or permanent permission is\n    // given. That doesn't matter for us though as we don't require labels.\n    return navigator.mediaDevices\n      .enumerateDevices()\n      .then((devices) => devices.some((device) => device.kind === 'videoinput'))\n      .catch(() => false)\n  }\n\n  constructor(\n    video,\n    onDecode,\n    canvasSizeOrOnDecodeError = this._onDecodeError,\n    canvasSizeOrCalculateScanRegion = this._calculateScanRegion,\n    preferredFacingMode = 'environment'\n  ) {\n    this.$video = video\n    this.$canvas = document.createElement('canvas')\n    this._onDecode = onDecode\n    this._legacyCanvasSize = QrScanner.DEFAULT_CANVAS_SIZE\n    this._preferredFacingMode = preferredFacingMode\n    this._active = false\n    this._paused = false\n    this._flashOn = false\n    this.cams = [] // 相机\n    this.activeDeviceId = null\n    this.permission = false // 相机权限\n\n    if (typeof canvasSizeOrOnDecodeError === 'number') {\n      // legacy function signature where the third argument is the canvas size\n      this._legacyCanvasSize = canvasSizeOrOnDecodeError\n      console.warn(\n        \"You're using a deprecated version of the QrScanner constructor which will be removed in \" +\n          'the future'\n      )\n    } else {\n      this._onDecodeError = canvasSizeOrOnDecodeError\n    }\n\n    if (typeof canvasSizeOrCalculateScanRegion === 'number') {\n      // legacy function signature where the fourth argument is the canvas size\n      this._legacyCanvasSize = canvasSizeOrCalculateScanRegion\n      console.warn(\n        \"You're using a deprecated version of the QrScanner constructor which will be removed in \" +\n          'the future'\n      )\n    } else {\n      this._calculateScanRegion = canvasSizeOrCalculateScanRegion\n    }\n\n    this._scanRegion = this._calculateScanRegion(video)\n\n    this._onPlay = this._onPlay.bind(this)\n    this._onLoadedMetaData = this._onLoadedMetaData.bind(this)\n    this._onVisibilityChange = this._onVisibilityChange.bind(this)\n\n    // Allow inline playback on iPhone instead of requiring full screen playback,\n    // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n    this.$video.playsInline = true\n    // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n    // includes no audio, but just to be safe.\n    this.$video.muted = true\n    this.$video.disablePictureInPicture = true\n    this.$video.addEventListener('play', this._onPlay)\n    this.$video.addEventListener('loadedmetadata', this._onLoadedMetaData)\n    document.addEventListener('visibilitychange', this._onVisibilityChange)\n\n    this._qrEnginePromise = QrScanner.createQrEngine()\n  }\n\n  /**\n   * 创建实例\n   * @param  {...any} arg 参数\n   */\n  static async create(...arg) {\n    const deviceInfo = await _requestPermission()\n    const scanner = new QrScanner(...arg)\n    scanner.permission = deviceInfo.permission\n    scanner.cams = deviceInfo.cams\n    return scanner\n  }\n\n  /* async */\n  hasFlash() {\n    if (!('ImageCapture' in window)) {\n      return Promise.resolve(false)\n    }\n\n    const track = this.$video.srcObject\n      ? this.$video.srcObject.getVideoTracks()[0]\n      : null\n    if (!track) {\n      return Promise.reject('Camera not started or not available')\n    }\n\n    const imageCapture = new ImageCapture(track)\n    return imageCapture\n      .getPhotoCapabilities()\n      .then((result) => {\n        return result.fillLightMode.includes('flash')\n      })\n      .catch((error) => {\n        console.warn(error)\n        return false\n      })\n  }\n\n  isFlashOn() {\n    return this._flashOn\n  }\n\n  /* async */\n  toggleFlash() {\n    return this._setFlash(!this._flashOn)\n  }\n\n  /* async */\n  turnFlashOff() {\n    return this._setFlash(false)\n  }\n\n  /* async */\n  turnFlashOn() {\n    return this._setFlash(true)\n  }\n\n  destroy() {\n    this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData)\n    this.$video.removeEventListener('play', this._onPlay)\n    document.removeEventListener('visibilitychange', this._onVisibilityChange)\n\n    this.stop()\n    QrScanner._postWorkerMessage(this._qrEnginePromise, 'close')\n  }\n\n  /* async */\n  start(deviceId) {\n    if (this._active && !this._paused) {\n      return Promise.resolve()\n    }\n    if (window.location.protocol !== 'https:') {\n      // warn but try starting the camera anyways\n      console.warn(\n        'The camera stream is only accessible if the page is transferred via https.'\n      )\n    }\n    this._active = true\n    this._paused = false\n    if (document.hidden) {\n      // camera will be started as soon as tab is in foreground\n      return Promise.resolve()\n    }\n    clearTimeout(this._offTimeout)\n    this._offTimeout = null\n    if (this.$video.srcObject) {\n      // camera stream already/still set\n      this.$video.play()\n      return Promise.resolve()\n    }\n    if (!deviceId) {\n      const backCam = this.cams.filter((cam) => {\n        return /rear|back|environment/i.test(cam.label)\n      })\n      const LEN = backCam.length\n      // 经过测试，在多摄像头的手机中，最后一个镜头视野是最合适的\n      if (LEN) {\n        deviceId = backCam[LEN - 1].deviceId\n      } else {\n        deviceId = this.cams.length && this.cams[this.cams.length - 1].deviceId\n      }\n    }\n    return this._getCameraStream(deviceId)\n      .then((stream) => {\n        // Try to determine the facing mode from the stream, otherwise use our guess. Note that the guess is not\n        // always accurate as Safari returns cameras of different facing mode, even for exact constraints.\n        this.$video.srcObject = stream\n        this.$video.play()\n        // this._setVideoMirror(facingMode)\n      })\n      .catch((e) => {\n        this._active = false\n        throw e\n      })\n  }\n\n  /**\n   * 重新启动摄像头\n   * @param {string} deviceId\n   */\n  restart(deviceId) {\n    this.stop()\n    setTimeout(() => {\n      this.start(deviceId)\n    }, 400)\n  }\n\n  stop() {\n    this.pause()\n    this._active = false\n  }\n\n  pause() {\n    this._paused = true\n    if (!this._active) {\n      return\n    }\n    this.$video.pause()\n    if (this._offTimeout) {\n      return\n    }\n    this._offTimeout = setTimeout(() => {\n      const tracks = this.$video.srcObject\n        ? this.$video.srcObject.getTracks()\n        : []\n      for (const track of tracks) {\n        track.stop() //  note that this will also automatically turn the flashlight off\n      }\n      this.$video.srcObject = null\n      this._offTimeout = null\n    }, 300)\n  }\n\n  /* async */\n  static scanImage(\n    imageOrFileOrUrl,\n    scanRegion = null,\n    qrEngine = null,\n    canvas = null,\n    fixedCanvasSize = false,\n    alsoTryWithoutScanRegion = false\n  ) {\n    const gotExternalWorker = qrEngine instanceof Worker\n\n    let promise = Promise.all([\n      qrEngine || QrScanner.createQrEngine(),\n      QrScanner._loadImage(imageOrFileOrUrl),\n    ]).then(([engine, image]) => {\n      qrEngine = engine\n      let canvasContext\n      ;[canvas, canvasContext] = this._drawToCanvas(\n        image,\n        scanRegion,\n        canvas,\n        fixedCanvasSize\n      )\n\n      if (qrEngine instanceof Worker) {\n        if (!gotExternalWorker) {\n          // Enable scanning of inverted color qr codes. Not using _postWorkerMessage as it's async\n          qrEngine.postMessage({ type: 'inversionMode', data: 'both' })\n        }\n        return new Promise((resolve, reject) => {\n          let timeout, onMessage, onError\n          onMessage = (event) => {\n            if (event.data.type !== 'qrResult') {\n              return\n            }\n            qrEngine.removeEventListener('message', onMessage)\n            qrEngine.removeEventListener('error', onError)\n            clearTimeout(timeout)\n            if (event.data.data !== null) {\n              resolve(event.data.data)\n            } else {\n              reject(QrScanner.NO_QR_CODE_FOUND)\n            }\n          }\n          onError = (e) => {\n            qrEngine.removeEventListener('message', onMessage)\n            qrEngine.removeEventListener('error', onError)\n            clearTimeout(timeout)\n            const errorMessage = !e ? 'Unknown Error' : e.message || e\n            reject('Scanner error: ' + errorMessage)\n          }\n          qrEngine.addEventListener('message', onMessage)\n          qrEngine.addEventListener('error', onError)\n          timeout = setTimeout(() => onError('timeout'), 10000)\n          const imageData = canvasContext.getImageData(\n            0,\n            0,\n            canvas.width,\n            canvas.height\n          )\n          qrEngine.postMessage(\n            {\n              type: 'decode',\n              data: imageData,\n            },\n            [imageData.data.buffer]\n          )\n        })\n      } else {\n        return new Promise((resolve, reject) => {\n          const timeout = setTimeout(\n            () => reject('Scanner error: timeout'),\n            10000\n          )\n          qrEngine\n            .detect(canvas)\n            .then((scanResults) => {\n              if (!scanResults.length) {\n                reject(QrScanner.NO_QR_CODE_FOUND)\n              } else {\n                resolve(scanResults[0].rawValue)\n              }\n            })\n            .catch((e) => reject('Scanner error: ' + (e.message || e)))\n            .finally(() => clearTimeout(timeout))\n        })\n      }\n    })\n\n    if (scanRegion && alsoTryWithoutScanRegion) {\n      promise = promise.catch(() =>\n        QrScanner.scanImage(\n          imageOrFileOrUrl,\n          null,\n          qrEngine,\n          canvas,\n          fixedCanvasSize\n        )\n      )\n    }\n\n    promise = promise.finally(() => {\n      if (gotExternalWorker) return\n      QrScanner._postWorkerMessage(qrEngine, 'close')\n    })\n\n    return promise\n  }\n\n  setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {\n    // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations work also\n    // well with colored qr codes.\n    QrScanner._postWorkerMessage(this._qrEnginePromise, 'grayscaleWeights', {\n      red,\n      green,\n      blue,\n      useIntegerApproximation,\n    })\n  }\n\n  setInversionMode(inversionMode) {\n    // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations scan normal\n    // and inverted qr codes by default\n    QrScanner._postWorkerMessage(\n      this._qrEnginePromise,\n      'inversionMode',\n      inversionMode\n    )\n  }\n\n  /* async */\n  static createQrEngine(workerPath = QrScanner.WORKER_PATH) {\n    return ('BarcodeDetector' in window\n      ? BarcodeDetector.getSupportedFormats()\n      : Promise.resolve([])\n    ).then((supportedFormats) =>\n      supportedFormats.indexOf('qr_code') !== -1\n        ? new BarcodeDetector({ formats: ['qr_code'] })\n        : new Worker(workerPath)\n    )\n  }\n\n  _onPlay() {\n    this._scanRegion = this._calculateScanRegion(this.$video)\n    this._scanFrame()\n  }\n\n  _onLoadedMetaData() {\n    this._scanRegion = this._calculateScanRegion(this.$video)\n  }\n\n  _onVisibilityChange() {\n    if (document.hidden) {\n      this.pause()\n    } else if (this._active) {\n      this.start()\n    }\n  }\n\n  _calculateScanRegion(video) {\n    // Default scan region calculation. Note that this can be overwritten in the constructor.\n    const smallestDimension = Math.min(video.videoWidth, video.videoHeight)\n    const scanRegionSize = Math.round((2 / 3) * smallestDimension)\n    return {\n      x: (video.videoWidth - scanRegionSize) / 2,\n      y: (video.videoHeight - scanRegionSize) / 2,\n      width: scanRegionSize,\n      height: scanRegionSize,\n      downScaledWidth: this._legacyCanvasSize,\n      downScaledHeight: this._legacyCanvasSize,\n    }\n  }\n\n  _scanFrame() {\n    if (!this._active || this.$video.paused || this.$video.ended) return false\n    // using requestAnimationFrame to avoid scanning if tab is in background\n    requestAnimationFrame(() => {\n      if (this.$video.readyState <= 1) {\n        // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n        // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n        // This also avoids false positives for videos paused after a successful scan which remains visible on\n        // the canvas until the video is started again and ready.\n        this._scanFrame()\n        return\n      }\n      this._qrEnginePromise\n        .then((qrEngine) =>\n          QrScanner.scanImage(\n            this.$video,\n            this._scanRegion,\n            qrEngine,\n            this.$canvas\n          )\n        )\n        .then(this._onDecode, (error) => {\n          if (!this._active) return\n          const errorMessage = error.message || error\n          if (errorMessage.indexOf('service unavailable') !== -1) {\n            // When the native BarcodeDetector crashed, create a new one\n            this._qrEnginePromise = QrScanner.createQrEngine()\n          }\n          this._onDecodeError(error)\n        })\n        .then(() => this._scanFrame())\n    })\n  }\n\n  _onDecodeError(error) {\n    // default error handler; can be overwritten in the constructor\n    if (error === QrScanner.NO_QR_CODE_FOUND) return\n    console.log(error)\n  }\n\n  _getCameraStream(deviceId) {\n    this.activeDeviceId = deviceId\n    const constraints = {\n      video: { deviceId: deviceId ? { exact: deviceId } : undefined },\n    }\n    return this._getMatchingCameraStream(constraints)\n  }\n\n  _getMatchingCameraStream(constraints) {\n    if (!navigator.mediaDevices) {\n      return Promise.reject('Camera not found.')\n    }\n    return navigator.mediaDevices.getUserMedia(constraints).catch((error) => {\n      console.log(error)\n    })\n  }\n\n  /* async */\n  _setFlash(on) {\n    return this.hasFlash()\n      .then((hasFlash) => {\n        if (!hasFlash) return Promise.reject('No flash available')\n        // Note that the video track is guaranteed to exist at this point\n        return this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n          advanced: [{ torch: on }],\n        })\n      })\n      .then(() => (this._flashOn = on))\n  }\n\n  _setVideoMirror(facingMode) {\n    // in user facing mode mirror the video to make it easier for the user to position the QR code\n    const scaleFactor = facingMode === 'user' ? -1 : 1\n    this.$video.style.transform = 'scaleX(' + scaleFactor + ')'\n  }\n\n  _getFacingMode(videoStream) {\n    const videoTrack = videoStream.getVideoTracks()[0]\n    if (!videoTrack) return null // unknown\n    // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n    return /rear|back|environment/i.test(videoTrack.label)\n      ? 'environment'\n      : /front|user|face/i.test(videoTrack.label)\n      ? 'user'\n      : null // unknown\n  }\n\n  static _drawToCanvas(\n    image,\n    scanRegion = null,\n    canvas = null,\n    fixedCanvasSize = false\n  ) {\n    canvas = canvas || document.createElement('canvas')\n    const scanRegionX = scanRegion && scanRegion.x ? scanRegion.x : 0\n    const scanRegionY = scanRegion && scanRegion.y ? scanRegion.y : 0\n    const scanRegionWidth =\n      scanRegion && scanRegion.width\n        ? scanRegion.width\n        : image.width || image.videoWidth\n    const scanRegionHeight =\n      scanRegion && scanRegion.height\n        ? scanRegion.height\n        : image.height || image.videoHeight\n    if (!fixedCanvasSize) {\n      canvas.width =\n        scanRegion && scanRegion.downScaledWidth\n          ? scanRegion.downScaledWidth\n          : scanRegionWidth\n      canvas.height =\n        scanRegion && scanRegion.downScaledHeight\n          ? scanRegion.downScaledHeight\n          : scanRegionHeight\n    }\n    const context = canvas.getContext('2d', { alpha: false })\n    context.imageSmoothingEnabled = false // gives less blurry images\n    context.drawImage(\n      image,\n      scanRegionX,\n      scanRegionY,\n      scanRegionWidth,\n      scanRegionHeight,\n      0,\n      0,\n      canvas.width,\n      canvas.height\n    )\n    return [canvas, context]\n  }\n\n  /* async */\n  static _loadImage(imageOrFileOrBlobOrUrl) {\n    if (\n      imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement ||\n      imageOrFileOrBlobOrUrl instanceof HTMLVideoElement ||\n      (window.ImageBitmap &&\n        imageOrFileOrBlobOrUrl instanceof window.ImageBitmap) ||\n      (window.OffscreenCanvas &&\n        imageOrFileOrBlobOrUrl instanceof window.OffscreenCanvas)\n    ) {\n      return Promise.resolve(imageOrFileOrBlobOrUrl)\n    } else if (imageOrFileOrBlobOrUrl instanceof Image) {\n      return QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl).then(\n        () => imageOrFileOrBlobOrUrl\n      )\n    } else if (\n      imageOrFileOrBlobOrUrl instanceof File ||\n      imageOrFileOrBlobOrUrl instanceof Blob ||\n      imageOrFileOrBlobOrUrl instanceof URL ||\n      typeof imageOrFileOrBlobOrUrl === 'string'\n    ) {\n      const image = new Image()\n      if (\n        imageOrFileOrBlobOrUrl instanceof File ||\n        imageOrFileOrBlobOrUrl instanceof Blob\n      ) {\n        image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl)\n      } else {\n        image.src = imageOrFileOrBlobOrUrl\n      }\n      return QrScanner._awaitImageLoad(image).then(() => {\n        if (\n          imageOrFileOrBlobOrUrl instanceof File ||\n          imageOrFileOrBlobOrUrl instanceof Blob\n        ) {\n          URL.revokeObjectURL(image.src)\n        }\n        return image\n      })\n    } else {\n      return Promise.reject('Unsupported image type.')\n    }\n  }\n\n  /* async */\n  static _awaitImageLoad(image) {\n    return new Promise((resolve, reject) => {\n      if (image.complete && image.naturalWidth !== 0) {\n        // already loaded\n        resolve()\n      } else {\n        let onLoad, onError\n        onLoad = () => {\n          image.removeEventListener('load', onLoad)\n          image.removeEventListener('error', onError)\n          resolve()\n        }\n        onError = () => {\n          image.removeEventListener('load', onLoad)\n          image.removeEventListener('error', onError)\n          reject('Image load error')\n        }\n        image.addEventListener('load', onLoad)\n        image.addEventListener('error', onError)\n      }\n    })\n  }\n\n  /* async */\n  static _postWorkerMessage(qrEngineOrQrEnginePromise, type, data) {\n    return Promise.resolve(qrEngineOrQrEnginePromise).then((qrEngine) => {\n      if (!(qrEngine instanceof Worker)) return\n      qrEngine.postMessage({ type, data })\n    })\n  }\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400\nQrScanner.NO_QR_CODE_FOUND = 'No QR code found'\nQrScanner.WORKER_PATH = 'qr-scanner-worker.min.js'\n"],"names":[],"mappings":"aAuBA,WAGA,EAAA,MAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}